use crate::lang::Lang;
use crate::ui::color_preview::ColorPreview;
use clap::Parser;
use ratatui::style::Color;
use serde::{Deserialize, Serialize};
use std::{
    fs::{self, File},
    io::{self, Write},
    process, thread, time,
};

#[derive(Deserialize, Serialize)]
#[serde(default)]
pub struct Config {
    pub lang: String,
    pub theme: Theme,
}

impl Default for Config {
    fn default() -> Self {
        Self {
            lang: "english".to_string(),
            theme: Theme::default(),
        }
    }
}

impl Config {
    pub fn get() -> std::io::Result<Self> {
        let a = Args::get()?;
        let p = dirs::config_local_dir().unwrap().join("arstyper.toml");
        let s = fs::read_to_string(&p).unwrap_or_else(|e| {
            println!(
                "Error reading from {}: {e}\nAttempting to create default config...",
                p.display()
            );
            let c = format!(
                "# Default config generated by arstyper\n{}",
                toml::to_string(&Self::default()).unwrap()
            );

            match File::create(&p) {
                Ok(mut f) => {
                    f.write_all(c.as_bytes()).unwrap();
                    println!("Sucessfully wrote default config to {}", p.display());
                }
                Err(e) => println!("Error creating {}: {e}", p.display()),
            }

            "".to_string() // faster than returning c, trust
        });

        let mut cfg: Self = toml::from_str(&s).unwrap_or_else(|e| {
            println!("{}: {e}\nProceeding with default config...", p.display());
            thread::sleep(time::Duration::from_millis(1500));
            Self::default()
        });

        // layer args over cfg
        if let Some(l) = a.lang {
            cfg.lang = l;
        }

        Ok(cfg)
    }
}

#[derive(Deserialize, Serialize)]
#[serde(default)]
pub struct Theme {
    fg: Color,
    bg: Color,
    typed_text: Color,
    untyped_text: Color,
    accent: Color,
}

impl Default for Theme {
    fn default() -> Self {
        Self {
            fg: Color::LightMagenta,
            bg: Color::DarkGray,
            typed_text: Color::LightCyan,
            untyped_text: Color::White,
            accent: Color::Magenta,
        }
    }
}

/// arstyper - a minimal terminal-based typing test
#[derive(Parser)]
#[command(version, about, long_about = None)]
struct Args {
    /// List available languages
    #[arg(long)]
    list: bool,
    /// Select language
    #[arg(short, long)]
    lang: Option<String>,
    /// Preview colors
    #[arg(long)]
    help_colors: bool,
    /// Print help about the config file
    #[arg(long)]
    help_config: bool,
}

impl Args {
    fn get() -> std::io::Result<Self> {
        let a = Self::parse();

        let mut ex = false;
        if a.list {
            let mut h = io::stdout().lock();
            let _ = writeln!(h, "Available languages:");
            for l in Lang::list() {
                let _ = writeln!(h, "  {}", l.file_name().unwrap().to_str().unwrap());
            }
            ex = true;
        } else if a.help_config {
            println!(
                r#"arstyper Configuration Information

The config file is automatically created on first run.
- Re-generate it by deleting the config and re-running the program.
- Unpopulated fields will use sane defaults.
- CLI options take priority over config options

The config file is located at one of the following locations:
  Linux: ~/.config/arstyper.toml
  MacOS: $HOME/Library/Application Support/arstyper.toml
  Windows: %localappdata%/arstyper.toml

To preview supported Theme Colors:
  arstyper --help-colors"#
            );
            ex = true;
        } else if a.help_colors {
            let c = ColorPreview::new();
            c.run()?;
            ex = true;
        }

        if ex {
            process::exit(0b0);
        }

        Ok(a)
    }
}
